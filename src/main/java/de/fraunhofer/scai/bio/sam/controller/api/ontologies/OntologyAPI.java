/**
 * NOTE: This class is auto generated by the swagger code generator program (2.3.1).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package de.fraunhofer.scai.bio.sam.controller.api.ontologies;

import java.io.File;
import java.util.List;

import javax.validation.Valid;

import org.semanticweb.owlapi.model.OWLOntologyCreationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;

import de.fraunhofer.scai.bio.sam.domain.DTO.ErrorDTO;
import de.fraunhofer.scai.bio.sam.domain.DTO.OntologyCheckDTO;
import de.fraunhofer.scai.bio.sam.domain.DTO.PagedOntologyDTO;
import de.fraunhofer.scai.bio.sam.service.exceptions.InvalidDataException;
import de.fraunhofer.scai.bio.sam.service.exceptions.NotFoundException;
import de.fraunhofer.scai.bio.sam.service.impl.ontology.SimpleOntologyServiceImpl;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;


/**
 * OntologyAPI
 * <p>
 * TODO: Add javadoc
 *
 * @author Marc Jacobs
 **/
@CrossOrigin(origins = "*")
@Controller

@Api(tags = {"Ontology"}, description = "Retrieve properties from an Ontology.")
public class OntologyAPI {
    Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    SimpleOntologyServiceImpl ontologyService;

    @ApiOperation(value = "Imports the given ontology into SAM", nickname = "import",
            notes = "Import the given ontology",
            tags = {"Ontology import"})
    @PostMapping("/api/v1/ontologies/{ontologyId}/")
    @ResponseStatus(value = HttpStatus.OK)
    
    public void uploadOntology(@PathVariable("ontologyId") String id,
            @ApiParam(value = "Where to load the ontology from.") @RequestParam("iri") String uploadLink,
            @ApiParam(value = "This allows to filter the response to only contain descriptions in a specific language. If no description in the given language is present non is returned. The API expect a language to be encoded as defined in https://tools.ietf.org/html/bcp47. Further an extension 'all' is allowed. If that is given properties in all language are returned. The default language is empty.", defaultValue = "") @Valid @RequestParam(value = "lang", required = false, defaultValue = "") String lang 
            ) throws InvalidDataException {

        if(uploadLink.isEmpty()) {
            throw new InvalidDataException();
        }

        try {
            ontologyService.loadOntology(id, uploadLink, lang);
        } catch (Exception e) {
            logger.error(e.getLocalizedMessage());
        }

    }

    @ApiOperation(value = "Export an ontology.",
            notes = "Set 'format' to specify export format. A file will be generated in the selected format.",
            tags = {"Ontology export",})
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Ok.",response = File.class)
    })
    @GetMapping(value = "/api/v1/ontologies/{ontologyId}/export/{format}", produces = MediaType.TEXT_PLAIN_VALUE )

    public HttpEntity<FileSystemResource> exportOntology(
            @ApiParam(value = "Identifier of the ontology.", required = true) @PathVariable("ontologyId") String ontologyId,
            @ApiParam(value = "Options are 'rdf', 'ttf', or 'owl'.", required = true, allowableValues = "rdf, ttf, owl") @PathVariable("format") String format
            ) throws Exception {

        HttpHeaders header = new HttpHeaders();
        header.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        header.setContentLength(-1);
        
        File export = null;
        export = ontologyService.saveOntology(ontologyId, format);
        
        if(export != null) {
            header.set(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=" + export.getName());
            header.setContentLength(export.length());
        }

        return new HttpEntity<FileSystemResource>(new FileSystemResource(export), header);
    }

    @ApiOperation(value = "List all ontologies", nickname = "listOntologies", notes = "Returns a terminology's meta information, including a link to the original source and a link to the local refined version, if present. Also returns links to changes and versionTags.", response = PagedOntologyDTO.class, 
            tags = {"Ontology retrieval"})
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Successful response", response = PagedOntologyDTO.class),
            @ApiResponse(code = 400, message = "Bad Client Request", response = ErrorDTO.class),
            @ApiResponse(code = 404, message = "Entity not found.", response = ErrorDTO.class)})
    @RequestMapping(value = "/api/v1/ontologies/",
    produces = {"application/json"},
    method = RequestMethod.GET)
    
    public ResponseEntity<PagedOntologyDTO> listOntologies(
            @ApiParam(value = "This allows to filter the response to only contain descriptions in a specific language. If no description in the given language is present non is returned. The API expect a language to be encoded as defined in https://tools.ietf.org/html/bcp47. Further an extension 'all' is allowed. If that is given properties in all language are returned. The default language is empty.", defaultValue = "") @Valid @RequestParam(value = "lang", required = false, defaultValue = "") String lang, 
            @ApiParam(value = "The requested page", defaultValue = "0", example = "1") @Valid @RequestParam(value = "page", required = false, defaultValue = "0") Long page, 
            @ApiParam(value = "Size of pages", defaultValue = "10", example = "10") @Valid @RequestParam(value = "size", required = false, defaultValue = "10") Long size
            ) {

        Page<String> ontologies = ontologyService.getAllOntologyIDs(PageRequest.of(page.intValue(), size.intValue()));

        PagedOntologyDTO pagedOntologyDTO = new PagedOntologyDTO();
        pagedOntologyDTO.setSize(ontologies.getSize());
        pagedOntologyDTO.setNumber(ontologies.getNumber());
        pagedOntologyDTO.setTotalPages(ontologies.getTotalPages());
        pagedOntologyDTO.setTotalElements((int) ontologies.getTotalElements());
        pagedOntologyDTO.setNumberOfElements(ontologies.getNumberOfElements());

        try {
            for (String ontologyID : ontologies.getContent()) {		    
                pagedOntologyDTO.addContentItem(ontologyService.getOntologyInfo(ontologyID));
            }
        } catch (NotFoundException e) {
            return new ResponseEntity<PagedOntologyDTO>(HttpStatus.NOT_FOUND);
        }

        return new ResponseEntity<PagedOntologyDTO>(pagedOntologyDTO, HttpStatus.OK);
    }

    @ApiOperation(value = "Generates for the given ontology different language versions and imports them into SAM", nickname = "languages",
            notes = "Generates and imports language specific ontologies",
            tags = {"Ontology build"})
    @PostMapping("/api/v1/ontologies/{ontologyId}/generate/languages")
    @ResponseStatus(value = HttpStatus.OK)
    
    public void generateLanguages(@PathVariable("ontologyId") String id
            )  {

        try {
            ontologyService.generateLanguageVersions(id);
        } catch (OWLOntologyCreationException e) {
            new ResponseEntity<PagedOntologyDTO>(HttpStatus.INTERNAL_SERVER_ERROR);
        } catch (NotFoundException e) {
            new ResponseEntity<PagedOntologyDTO>(HttpStatus.NOT_FOUND);
        }
    }

    @ApiOperation(value = "Generates for the given ontology different text mining bins and imports them into SAM", nickname = "text-mining",
            notes = "Generates and imports text mining bins",
            tags = {"Ontology build",})
    @PostMapping("/api/v1/ontologies/{ontologyId}/generate/text-mining-bins")
    @ResponseStatus(value = HttpStatus.OK)
    
    public void generateTextMiningBins(@PathVariable("ontologyId") String id,
            @ApiParam(value = "Skip BFO part", required = false, defaultValue = "true") @RequestParam("BFO") boolean skipBFO,
            @ApiParam(value = "Options are 'HERMIT, 'STRUCTURAL'.", required = true, allowableValues = "HERMIT, STRUCTURAL") @RequestParam("reasoner") String reasoning
            )  {

        try {
            List<String> generated = ontologyService.generateTextMiningBins(id, reasoning, skipBFO);
            logger.info(" >> created: {}", generated.toString());
        } catch (OWLOntologyCreationException e) {
            new ResponseEntity<PagedOntologyDTO>(HttpStatus.INTERNAL_SERVER_ERROR);
        } catch (NotFoundException e) {
            new ResponseEntity<PagedOntologyDTO>(HttpStatus.NOT_FOUND);
        }
    }
    
    
    @ApiOperation(value = "Run ontology checker",
            notes = "Uses reasoner to check some properties of the ontology",
            response = OntologyCheckDTO.class, 
            tags = {"Ontology retrieval"})
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "Successful response", response = OntologyCheckDTO.class),
            @ApiResponse(code = 400, message = "Bad Client Request", response = ErrorDTO.class),
            @ApiResponse(code = 404, message = "Entity not found.", response = ErrorDTO.class)})    
    @RequestMapping(value = "/api/v1/ontologies/{ontologyId}/check",
            produces = {"application/json"},
            method = RequestMethod.GET)
        
    ResponseEntity<OntologyCheckDTO> checkOntology(
            @PathVariable("ontologyId") String id,
            @ApiParam(value = "Options are 'HERMIT, 'STRUCTURAL'.", required = true, allowableValues = "HERMIT, STRUCTURAL") @RequestParam("reasoner") String reasoning
            )  {

        OntologyCheckDTO result=null; 
        try {
             result = ontologyService.check(id, reasoning);
        } catch (NotFoundException e) {
            new ResponseEntity<PagedOntologyDTO>(HttpStatus.NOT_FOUND);
        }
        
        return new ResponseEntity<OntologyCheckDTO>(result, HttpStatus.OK);
    }


}
